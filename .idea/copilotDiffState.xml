<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/lib/firestore2.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/lib/firestore2.js" />
              <option name="originalContent" value="// lib/firestore.js に以下の関数を追加&#10;&#10;import {&#10;    collection,&#10;    doc,&#10;    addDoc,&#10;    updateDoc,&#10;    deleteDoc,&#10;    getDocs,&#10;    getDoc,&#10;    query,&#10;    where,&#10;    orderBy,&#10;    limit,&#10;    onSnapshot,&#10;    serverTimestamp,&#10;    increment&#10;} from 'firebase/firestore';&#10;import { db } from './firebase';&#10;&#10;// フレンド関連の関数&#10;&#10;// ユーザーのフレンド一覧を取得&#10;export const getUserFriends = (userId, callback, errorCallback) =&gt; {&#10;    try {&#10;        const friendsRef = collection(db, 'friends');&#10;        const q = query(&#10;            friendsRef,&#10;            where('participants', 'array-contains', userId)&#10;        );&#10;        return onSnapshot(q, callback, errorCallback);&#10;    } catch (error) {&#10;        console.error('フレンド取得エラー:', error);&#10;        if (errorCallback) errorCallback(error);&#10;    }&#10;};&#10;&#10;// フレンドリクエストを送信&#10;export const sendFriendRequest = async (senderId, senderName, receiverEmail) =&gt; {&#10;    try {&#10;        // 受信者のユーザー情報を取得&#10;        const usersRef = collection(db, 'users');&#10;        const q = query(usersRef, where('email', '==', receiverEmail));&#10;        const querySnapshot = await getDocs(q);&#10;&#10;        if (querySnapshot.empty) {&#10;            throw new Error('指定されたメールアドレスのユーザーが見つかりません');&#10;        }&#10;&#10;        const receiverDoc = querySnapshot.docs[0];&#10;        const receiverId = receiverDoc.id;&#10;        const receiverData = receiverDoc.data();&#10;&#10;        if (receiverId === senderId) {&#10;            throw new Error('自分自身にフレンドリクエストを送ることはできません');&#10;        }&#10;&#10;        // 既存のフレンド関係をチェック&#10;        const friendsRef = collection(db, 'friends');&#10;        const existingQuery = query(&#10;            friendsRef,&#10;            where('participants', 'array-contains', senderId)&#10;        );&#10;        const existingSnapshot = await getDocs(existingQuery);&#10;&#10;        const existingFriend = existingSnapshot.docs.find(doc =&gt;&#10;            doc.data().participants.includes(receiverId)&#10;        );&#10;&#10;        if (existingFriend) {&#10;            const status = existingFriend.data().status;&#10;            if (status === 'accepted') {&#10;                throw new Error('既にフレンドです');&#10;            } else if (status === 'pending') {&#10;                throw new Error('既にフレンドリクエストを送信済みです');&#10;            }&#10;        }&#10;&#10;        // フレンドリクエストを作成&#10;        await addDoc(friendsRef, {&#10;            senderId,&#10;            senderName,&#10;            receiverId,&#10;            receiverName: receiverData.displayName || '匿名',&#10;            participants: [senderId, receiverId],&#10;            status: 'pending',&#10;            createdAt: serverTimestamp()&#10;        });&#10;&#10;        console.log('フレンドリクエスト送信完了');&#10;    } catch (error) {&#10;        console.error('フレンドリクエスト送信エラー:', error);&#10;        throw error;&#10;    }&#10;};&#10;&#10;// フレンドリクエストを承認&#10;export const acceptFriendRequest = async (requestId, userId, userName, friendId, friendName) =&gt; {&#10;    try {&#10;        const friendRef = doc(db, 'friends', requestId);&#10;        await updateDoc(friendRef, {&#10;            status: 'accepted',&#10;            acceptedAt: serverTimestamp()&#10;        });&#10;&#10;        console.log('フレンドリクエスト承認完了');&#10;    } catch (error) {&#10;        console.error('フレンドリクエスト承認エラー:', error);&#10;        throw error;&#10;    }&#10;};&#10;&#10;// フレンドリクエストを拒否&#10;export const declineFriendRequest = async (requestId) =&gt; {&#10;    try {&#10;        const friendRef = doc(db, 'friends', requestId);&#10;        await deleteDoc(friendRef);&#10;        console.log('フレンドリクエスト拒否完了');&#10;    } catch (error) {&#10;        console.error('フレンドリクエスト拒否エラー:', error);&#10;        throw error;&#10;    }&#10;};&#10;&#10;// DM関連の関数&#10;&#10;// ユーザーのDMチャンネル一覧を取得&#10;export const getUserDMs = (userId, callback, errorCallback) =&gt; {&#10;    try {&#10;        const channelsRef = collection(db, 'channels');&#10;        const q = query(&#10;            channelsRef,&#10;            where('type', '==', 'dm'),&#10;            where('participants', 'array-contains', userId),&#10;            orderBy('lastMessageAt', 'desc')&#10;        );&#10;        return onSnapshot(q, callback, errorCallback);&#10;    } catch (error) {&#10;        console.error('DM取得エラー:', error);&#10;        // lastMessageAtでソートできない場合はcreatedAtでソート&#10;        const channelsRef = collection(db, 'channels');&#10;        const q = query(&#10;            channelsRef,&#10;            where('type', '==', 'dm'),&#10;            where('participants', 'array-contains', userId),&#10;            orderBy('createdAt', 'desc')&#10;        );&#10;        return onSnapshot(q, callback, errorCallback);&#10;    }&#10;};&#10;&#10;// DMチャンネルを作成&#10;export const createDMChannel = async (userId, friendId, userName, friendName) =&gt; {&#10;    try {&#10;        // 既存のDMチャンネルがあるかチェック&#10;        const channelsRef = collection(db, 'channels');&#10;        const q = query(&#10;            channelsRef,&#10;            where('type', '==', 'dm'),&#10;            where('participants', 'array-contains', userId)&#10;        );&#10;        const querySnapshot = await getDocs(q);&#10;&#10;        const existingDM = querySnapshot.docs.find(doc =&gt; {&#10;            const data = doc.data();&#10;            return data.participants.includes(friendId) &amp;&amp; data.participants.includes(userId);&#10;        });&#10;&#10;        if (existingDM) {&#10;            return {&#10;                id: existingDM.id,&#10;                ...existingDM.data()&#10;            };&#10;        }&#10;&#10;        // 新しいDMチャンネルを作成&#10;        const dmRef = await addDoc(channelsRef, {&#10;            type: 'dm',&#10;            participants: [userId, friendId],&#10;            participantNames: {&#10;                [userId]: userName,&#10;                [friendId]: friendName&#10;            },&#10;            createdAt: serverTimestamp(),&#10;            lastMessage: null,&#10;            lastMessageAt: null&#10;        });&#10;&#10;        console.log('DMチャンネル作成完了:', dmRef.id);&#10;&#10;        return {&#10;            id: dmRef.id,&#10;            type: 'dm',&#10;            participants: [userId, friendId],&#10;            participantNames: {&#10;                [userId]: userName,&#10;                [friendId]: friendName&#10;            }&#10;        };&#10;    } catch (error) {&#10;        console.error('DMチャンネル作成エラー:', error);&#10;        throw error;&#10;    }&#10;};&#10;&#10;// DMにメッセージを送信（既存のsendMessage関数を使用するが、DMチャンネルの最終メッセージ更新を追加）&#10;export const sendDMMessage = async (channelId, userId, userName, content, replyToId = null) =&gt; {&#10;    try {&#10;        // メッセージを追加&#10;        const messagesRef = collection(db, 'messages');&#10;        const messageData = {&#10;            channelId,&#10;            userId,&#10;            userName,&#10;            content,&#10;            timestamp: serverTimestamp(),&#10;            edited: false&#10;        };&#10;&#10;        if (replyToId) {&#10;            // 返信先のメッセージ内容を取得&#10;            const replyToRef = doc(db, 'messages', replyToId);&#10;            const replyToDoc = await getDoc(replyToRef);&#10;            if (replyToDoc.exists()) {&#10;                messageData.replyTo = replyToDoc.data().content.substring(0, 50) + (replyToDoc.data().content.length &gt; 50 ? '...' : '');&#10;                messageData.replyToId = replyToId;&#10;            }&#10;        }&#10;&#10;        await addDoc(messagesRef, messageData);&#10;&#10;        // DMチャンネルの最終メッセージ情報を更新&#10;        const channelRef = doc(db, 'channels', channelId);&#10;        await updateDoc(channelRef, {&#10;            lastMessage: content.substring(0, 50) + (content.length &gt; 50 ? '...' : ''),&#10;            lastMessageAt: serverTimestamp(),&#10;            lastMessageUserId: userId,&#10;            lastMessageUserName: userName&#10;        });&#10;&#10;        console.log('DMメッセージ送信完了');&#10;    } catch (error) {&#10;        console.error('DMメッセージ送信エラー:', error);&#10;        throw error;&#10;    }&#10;};&#10;&#10;// 既存のsendMessage関数を拡張してDMに対応&#10;export const sendMessage = async (channelId, userId, userName, content, replyToId = null, attachmentId = null) =&gt; {&#10;    try {&#10;        // チャンネル情報を取得してDMかどうか判定&#10;        const channelRef = doc(db, 'channels', channelId);&#10;        const channelDoc = await getDoc(channelRef);&#10;&#10;        const messagesRef = collection(db, 'messages');&#10;        const messageData = {&#10;            channelId,&#10;            userId,&#10;            userName,&#10;            content,&#10;            timestamp: serverTimestamp(),&#10;            edited: false&#10;        };&#10;&#10;        if (replyToId) {&#10;            // 返信先のメッセージ内容を取得&#10;            const replyToRef = doc(db, 'messages', replyToId);&#10;            const replyToDoc = await getDoc(replyToRef);&#10;            if (replyToDoc.exists()) {&#10;                messageData.replyTo = replyToDoc.data().content.substring(0, 50) + (replyToDoc.data().content.length &gt; 50 ? '...' : '');&#10;                messageData.replyToId = replyToId;&#10;            }&#10;        }&#10;&#10;        if (attachmentId) {&#10;            messageData.attachments = [{&#10;                id: attachmentId,&#10;                type: 'image'&#10;            }];&#10;        }&#10;&#10;        await addDoc(messagesRef, messageData);&#10;&#10;        // DMチャンネルの場合は最終メッセージ情報を更新&#10;        if (channelDoc.exists() &amp;&amp; channelDoc.data().type === 'dm') {&#10;            await updateDoc(channelRef, {&#10;                lastMessage: content.substring(0, 50) + (content.length &gt; 50 ? '...' : ''),&#10;                lastMessageAt: serverTimestamp(),&#10;                lastMessageUserId: userId,&#10;                lastMessageUserName: userName&#10;            });&#10;        }&#10;&#10;        console.log('メッセージ送信完了');&#10;    } catch (error) {&#10;        console.error('メッセージ送信エラー:', error);&#10;        throw error;&#10;    }&#10;};&#10;&#10;// フレンドをブロック&#10;export const blockFriend = async (userId, friendId) =&gt; {&#10;    try {&#10;        const blocksRef = collection(db, 'blocks');&#10;        await addDoc(blocksRef, {&#10;            userId,&#10;            blockedUserId: friendId,&#10;            createdAt: serverTimestamp()&#10;        });&#10;&#10;        // フレンド関係を削除&#10;        const friendsRef = collection(db, 'friends');&#10;        const q = query(&#10;            friendsRef,&#10;            where('participants', 'array-contains', userId)&#10;        );&#10;        const querySnapshot = await getDocs(q);&#10;&#10;        const friendDoc = querySnapshot.docs.find(doc =&gt;&#10;            doc.data().participants.includes(friendId)&#10;        );&#10;&#10;        if (friendDoc) {&#10;            await deleteDoc(doc(db, 'friends', friendDoc.id));&#10;        }&#10;&#10;        console.log('ユーザーをブロックしました');&#10;    } catch (error) {&#10;        console.error('ブロックエラー:', error);&#10;        throw error;&#10;    }&#10;};&#10;&#10;// ブロックを解除&#10;export const unblockFriend = async (userId, friendId) =&gt; {&#10;    try {&#10;        const blocksRef = collection(db, 'blocks');&#10;        const q = query(&#10;            blocksRef,&#10;            where('userId', '==', userId),&#10;            where('blockedUserId', '==', friendId)&#10;        );&#10;        const querySnapshot = await getDocs(q);&#10;&#10;        querySnapshot.docs.forEach(async (blockDoc) =&gt; {&#10;            await deleteDoc(doc(db, 'blocks', blockDoc.id));&#10;        });&#10;&#10;        console.log('ブロックを解除しました');&#10;    } catch (error) {&#10;        console.error('ブロック解除エラー:', error);&#10;        throw error;&#10;    }&#10;};&#10;&#10;// ブロックされたユーザー一覧を取得&#10;export const getBlockedUsers = (userId, callback, errorCallback) =&gt; {&#10;    try {&#10;        const blocksRef = collection(db, 'blocks');&#10;        const q = query(&#10;            blocksRef,&#10;            where('userId', '==', userId)&#10;        );&#10;        return onSnapshot(q, callback, errorCallback);&#10;    } catch (error) {&#10;        console.error('ブロック一覧取得エラー:', error);&#10;        if (errorCallback) errorCallback(error);&#10;    }&#10;};&#10;&#10;// DMチャンネルを削除（非表示）&#10;export const hideDMChannel = async (channelId, userId) =&gt; {&#10;    try {&#10;        // DMチャンネルに非表示フラグを追加&#10;        const channelRef = doc(db, 'channels', channelId);&#10;        const channelDoc = await getDoc(channelRef);&#10;&#10;        if (channelDoc.exists()) {&#10;            const data = channelDoc.data();&#10;            const hiddenFor = data.hiddenFor || [];&#10;&#10;            if (!hiddenFor.includes(userId)) {&#10;                hiddenFor.push(userId);&#10;                await updateDoc(channelRef, {&#10;                    hiddenFor&#10;                });&#10;            }&#10;        }&#10;&#10;        console.log('DMチャンネルを非表示にしました');&#10;    } catch (error) {&#10;        console.error('DMチャンネル非表示エラー:', error);&#10;        throw error;&#10;    }&#10;};&#10;&#10;// DMチャンネルを表示&#10;export const showDMChannel = async (channelId, userId) =&gt; {&#10;    try {&#10;        const channelRef = doc(db, 'channels', channelId);&#10;        const channelDoc = await getDoc(channelRef);&#10;&#10;        if (channelDoc.exists()) {&#10;            const data = channelDoc.data();&#10;            const hiddenFor = data.hiddenFor || [];&#10;            const newHiddenFor = hiddenFor.filter(id =&gt; id !== userId);&#10;&#10;            await updateDoc(channelRef, {&#10;                hiddenFor: newHiddenFor&#10;            });&#10;        }&#10;&#10;        console.log('DMチャンネルを表示しました');&#10;    } catch (error) {&#10;        console.error('DMチャンネル表示エラー:', error);&#10;        throw error;&#10;    }&#10;};&#10;&#10;// オンラインステータス更新&#10;export const updateOnlineStatus = async (userId, status) =&gt; {&#10;    try {&#10;        const userRef = doc(db, 'users', userId);&#10;        await updateDoc(userRef, {&#10;            onlineStatus: status,&#10;            lastSeen: serverTimestamp()&#10;        });&#10;    } catch (error) {&#10;        console.error('オンラインステータス更新エラー:', error);&#10;        throw error;&#10;    }&#10;};&#10;&#10;// ユーザーのオンラインステータスを取得&#10;export const getUserOnlineStatus = (userId, callback, errorCallback) =&gt; {&#10;    try {&#10;        const userRef = doc(db, 'users', userId);&#10;        return onSnapshot(userRef, callback, errorCallback);&#10;    } catch (error) {&#10;        console.error('オンラインステータス取得エラー:', error);&#10;        if (errorCallback) errorCallback(error);&#10;    }&#10;};" />
              <option name="updatedContent" value="// このファイルの内容はfirestore.jsに統合されました。今後はfirestore.jsのみを使用してください。" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>